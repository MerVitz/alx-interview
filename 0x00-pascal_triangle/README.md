# 0x00. Pascal's Triangle  
**Algorithm | Python**

## Project Overview  
This project focuses on implementing **Pascal's Triangle** in Python. You are required to generate the triangle as a **list of lists**, where each list represents a row in the triangle. 

The project helps reinforce key Python concepts such as **lists, loops, functions, recursion, and arithmetic operations**. By mastering this task, you improve your problem-solving skills and algorithmic thinking.

---

## Learning Objectives  

### To Successfully Complete This Project, You Should Master the Following Python Concepts:

1. **Lists and List Comprehensions**  
   - Understand how to create, access, modify, and iterate over lists.  
   - Utilize **list comprehensions** for concise code, especially for generating rows of Pascal’s Triangle.

2. **Functions**  
   - Know how to define and call functions.  
   - Pass parameters and return values, particularly how to return **a list of lists** representing Pascal’s Triangle.

3. **Loops**  
   - Use `for` and `while` loops to iterate through sequences.  
   - Implement **nested loops** to generate each row of Pascal’s Triangle.

4. **Conditional Statements**  
   - Apply `if`, `elif`, and `else` conditions to handle logic, such as setting the **edges to 1** in Pascal’s Triangle.

5. **Recursion (Optional)**  
   - Learn how recursion provides an alternative way to generate Pascal’s Triangle.  
   - Recognize **base and recursive cases** when implementing a recursive function.

6. **Arithmetic Operations**  
   - Use **addition** to calculate each element in Pascal’s Triangle as the sum of two elements directly above it.

7. **Indexing and Slicing**  
   - Access elements and slices of lists to correctly sum elements when constructing a new row.

8. **Memory Management**  
   - Be mindful of how lists are stored and copied when generating new rows.

9. **Error and Exception Handling (Optional)**  
   - Use `try-except` blocks to handle **invalid inputs** gracefully.

10. **Efficiency and Optimization**  
    - Evaluate the **time and space complexity** of your approach.  
    - Apply optimizations to ensure the solution runs efficiently for larger inputs.
